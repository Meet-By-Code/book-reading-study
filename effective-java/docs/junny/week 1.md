### item 1

>  생성자 대신 정적 팩터리 메서드를 고려

1. 이름을 가질수있다
   이는 가독성을 의미한다
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
   이는 큰 객체일수록 성능을 끌어올려준다
    인스턴스의 생명주기를 다루는데 용이하다.
3. 반환 타입의 하위타입 객체를 반환할 수 있는 능력이 있다
   이는 '유연성'을 의미한다
    API의 크기가 작아짐과 가독성 및 코드 구현 난이도 저하로 이어진다.
    '정적 필드와 정적 멤버 클래스는 Public'
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
   클래스의 확장 가능성 및 이용자의 편의를 증가시킨다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
   프라임워크 사용자에게 기본구현체 & 커스텀 구현체를 선택할 수 있도록 해준다.
    !!
    상속을 위해서는 public이나 protected 생성자가 필요하니 정적메소드로는 하위클래스를 만들 수 없다
    프로그래머가 찾기 어렵디
##### *static method로 성능을 이끌어내자,,!*

---

### item 2

>  생성자에 매개변수가 많다면 빌더를 고려하라.

###### i ) 점층적 생성자

bad : 쓸수는 있지만 매개변수의 수가 많아지면 코드 가독성이 떨어진다

###### ii ) Setter (java beans)

good : 인스턴스 생성이 쉽고 읽기쉬운코드
bad : 여러 메서드를 호출해야 하며, 객체완성 전에는 일관성이 무너진다.

###### iii ) 빌더 패턴

good :
객체를 직접 만드는 대신 필수 매개변수로 생성자를 호출해 빌더 객체를 얻는다
[ 메서드 연쇄 , 플루언트 API ]
계층적으로 설계된 클래스와 함께 쓰기 좋다.
bad :
빌더의 생성비용, 매개변수의 개수가 충분한지를 확인한다

*

##### *직접적인 setter 보단 builder가 유용!*

---

### item 3

>  private 생성자나 열거타입으로 싱글턴을 보증하라.

*[ 싱글턴 : 인스턴스를 오직 하나만 생성할 수 있는 클래스 ]*

*[ 클래스를 싱글턴으로 만들면 테스트가 용이하지 않다 ]*

######  field type

* private 생성자는 instance 초기화할 때 딱 한번만 호출된다

이로써 전체 시스템상 유일한 인스턴스임이 보증된다

* static factory type ☆☆

싱글턴 방식임이 명백하게 드러난다.
final 필드이니 다른객체를 참조할수 없는 간결성을 가진다.
메서드 참조를 공급자(supplier)로 사용할 수 있다

```
EX) FACTORY::getInstance -> Supplier<FACTORY></FACTORY>
```

* Enum type

간결하며, 별다른 노력 없이 직렬화 할수 있다.



---

### item 4

>  인스턴스화를 막으려거든 private 생성자를 사용하라

 추상클래스만 으로는 인스턴스화를 막을 수 없다.
 ! private 생성자로 인스턴스화를 막을 수 있다.



###### *no argument construct는 못쓰게 막는게  여러므로 편할거같다*

---

### item 5

>  자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

사용하는 자원에 따라 동작이 달라지는 클래스에서는
의존 객체 주입을 사용하자!
자원과 의존관계의 상관없이 동작하게 할 수 있다.

----

### item 6

>  불필요한 객체 생성을 피하라

  성능이 중요한 상황에서 반복해 객체를 생성하는것은 적합하지 않다

    1. 데이터 베이스 연결은 생성비용이 비싸니 재사용
    2. 객체 풀을 스스로 만드는것 보다 가비지 컬렉터를 믿자

---

### item 7

> 다 쓴 객체 참조를 해제하라

 객체 참조를 해제하면 가비지 컬렉터는 그 객체가 참조하는 모든 객체를 회수하지 못한다.
 ! 비활성 영역의 객체는 null 처리해서 쓰지 않을 것을 명시
 ! 자기 메모리를 직접 관리하는 클래스는 항시 메모리 누수에 주의

###### *메모리 , 캐시 , 리스너&콜백은 항상 주의하자*

---

### item 8

>  finalizer 와 cleaner 사용을 피하라

###### finalizer

예측 불가능 하며 상황에 따라 위험할 수 있어 불필요하다

###### cleaner

예측 불가능 하며 느리고, 불필요하다

이 둘은 제때 실행되어야 하는 작업은 할수없다.
! 상태를 영구적으로 수정하는 작업에서는 절대 사용하지 않는다.



###### *그냥 쓰지말자 !*

---

### item 9

>  Try-finally 보다 try-with-resource를 사용하라

try-finally의 문제 ( Catch 시 close 메서드를 실패시키는)를 

해결하는 AutoCloseable (해당 자원이 implement )를

닫을 자원이 존재한다면, AutoCloseable을 구현하도록 한다

###### *try-with-resource 를 이용하여 코드 가독성과 실속을 챙기자.*

----

### item 10

>  Equals 는 일반 규약을 지켜 재정의하라

 반사성 : null이 이닌 모든 참조값 x의 x.euqls(x) = true
  두 객체는 서로에대한 동치 여부에 같은 값을 가진다
 대칭성 : null이 아닌 모든 참조값 x,y의 역함수는 같다 x.equals(y) == y.eqauls(x)
  두 객체는 동치여부에 똑같은 답을 한다

 추이성 : null이 아닌 모든 참조값 x,y,z의 x.equals(y) y.equals(z)면 z.equals(x) 도 같다
  세 객체는 삼단추론을 참으로 가진다.

######   [ 리스코프 치환 원칙 : 중요한 속성은 하위 타입에서도 중요하다.

###### 그타입의 모든 메서드는 하위 타입에서도 똑같이 잘 작동해야 한다 ]

 일관성 : null이 아닌 모든 참조값 x,y의 x.equals(y)의 반복호출은 항상 같은값을 반환한다
   불변객체는 영원히 같은 결과를 반환하도록 만들어야 한다.
   equals에는 신뢰할 수 없는 자원이 끼어들지 않도록 한다.
 NonNull : null이 아닌 모든 참조값 x의 x.equals(null) 은 false다
   모든 객체는 null이 아니도록 한다.

######  EQUALS 구현 방법

    1. == 를 사용해 자기 자신의 참조 인지 확인
    2. instanceof 로 올바른 타입인지 확인
    3. 입력을 올바른 타입으로 형 변환한다.
    4. 입력 객체와 자기자신과 대응되는 핵심 필드들이 모두 일치하는지 검사.

###### EQUALS 재정의 X 유형

1. 각 인스턴스가 본질적으로 고유하다
  값을 표현하는 게 아니라 동작하는 개체를 표헌하는 클래스
   EX) THREAD
2. 인스턴스의 논리적 동치성을 검사할 일이 없다.
  두 Patern의 인스턴스가 정규표현식을 나타내는지 검사, ( 논리적 동치)
  하는 경우가 아니라면 Object의 Equal로 충분하다
3. 상위 클래스의 Equals가 하위에도 들어맞는다.
  Set, List, Map 등은 필요하지 않다.
4. 클래스가 Private & package-private 또는 Equals를 호출할 일이 없다
   쓸일이 없을때는 재정의하여 Exception 처리한다

###### EQUALS 재정의 O 유형

* 논리적 동치성을 확인해야 하지만 상위클래스에서 재정의 되지 않았을때

주로 값 클래스가 해당된다. ( Integer & String )
Bad case의 3과 반대되는 경우라고 볼수 있다.



######  * equals 사용시에는 hashcode도 재정의한다.*

######  *복잡하게 짜지 말것*

---

### item 11

> Equals를 재정의 하려거든 Hashcode도 재정의 하라

Equals를 재정의한 클래스 모두에서 hashCode도 재정의 해야한다.
 ⇒ Equals 비교에는 사용되는 정보가 변경되지 않았다면 어플리케이션이 실행되는 동안,
 그 객체의 hashcode도 일관된 값을 반환해야 한다
 ⇒ equals가 두객체를 같다고 판단했다면, 두 객체의 hashcode는 똑같은 값을 반환
 ⇒ equals가 두객체를 다르다고 판단 했더라고 hashcode가 다를 필요는 없다.

######  Hashcode 작성 요령

    1. int result = [임의값]
    2. 해당 필드의 해시코드 [임의값] 을 계산
       ㄱ. 기본 타입 필드 -> type.hashcode(Field) 를 수행
          ㄴ. 참조 타입 필드면서 이클래스의 euqals메서드가 이 필드의 equals를 재귀적으로 호출해 비교
          ㄷ. 필드가 배열 이라면 핵심원소를 각각 별도 필드처럼 다룬다.
    3. 2에서 계산한 해시코드 [임의값]으로 result를 갱신&반환한다

---

### item 12

>  toString을 항상 재정의하라

toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스로 인한 디버깅이 쉽다
그객체가 가지는 주요 정보 모두를 반환하는 게 좋다
포맷을 명시하던 안하던 여러분의 의도는 명확히 밝혀야 한다

---

### item 13

> clone 재정의는 주의해서 진행하라

 Cloneable을 구현한 클래스에서 clone을 호출하면 그객체의 필드들을 하나하나 [ 복사 ] 한 객체를 반환환다
 clone은 생성자와 같은 효과를 가진다. ( = 불변식을 보장해야 한다 )

 복제본이 가변변수 일경우 깊은복사 & final을 고려해야 한다.

 Cloneable을 구현하는 모든 클래스는 clone을 재정의 해야한다. ( + 깊은복사 .. )

######  *..! cloneable을 쓰지말라 ( 모르면) 는 내용으로 보인다..!*

######  *쓴적도 없지만,, 더편한 복사팩터리/변환팩터리를 사용하도록 한다.*

---

### item 14

>  Comparable을 구현할지 고려하라.

! CompareTo
CompareTo는 동치성 & 순서 비교가 가능하며 [ 제너릭 ] 하다.
CompareTo는 Equals와 규약이 비슷하다.

1. 두 객체의 순서를 바꿔도 예상한 결과가 나와야 한다.
2. A > B > C일때 A > C를 성립해야한다
3. 크기가 같은 객체는 어떤 객체던지 항상 같아야 한다.
  작성요령은 Equals와 비슷하다다
  관계연산자< > 은 거추장 스러우니 추천하지 않는다
