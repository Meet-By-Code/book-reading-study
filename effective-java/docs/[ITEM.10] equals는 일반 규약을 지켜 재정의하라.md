# equals를 재정의하지 않는 것이 최선인 경우

- 각 인스턴스가 본질적으로 고유하다
- 인스턴스의 `논리적 동치성(Logical Equality)`을 검사할 일이 없다
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다

# equals를 재정의해야 할 경우

객체 식별성(object identity; 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때

보통 VO(값 객체)가 여기에 포함된다. 싱글톤 객체의 경우 둘 이상이 존재하지 않으니 재정의하지 않아도 된다.

# equals를 재정의할 때는 `Object 명세 규약`를 만족해야 한다

equals 메소드는 Object 명세에 적힌 동치관계(equivalence relation)라는 규약을 구현하며 다음을 만족해야 한다.

**(기본적으로 모든 참조 값이 null이 아니어야 함)**

- **반사성(reflexivity)** - 객체는 자기 자신과 같아야 한다(A랑 A는 같다)
- **대칭성(symmetry)** - 서로에 대한 동치 여부는 똑같아야 한다(A랑 B가 같으면, B랑 A도 같다)
- **추이성(transitivity)** - A랑 B가 같고, B랑 C가 같을 때 A랑 C도 같아야 한다
- **일관성(consistency)** - 두 객체가 같다면 수정되지 않는 한 앞으로도 영원히 같아야 한다
- **널아님(not null)** - 모든 객체가 null과 같지 않아야 한다

# 주의 사항

- equals를 재정의할 땐 hashCode도 반드시 재정의하자
- 너무 복잡하게 해결하려 들지 말자
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자
